import { TYPE_BOOST_ITEM_BOOST_PERCENT } from "#app/constants";
import { timedEventManager } from "#app/global-event-manager";
import { globalScene } from "#app/global-scene";
import { getPokemonNameWithAffix } from "#app/messages";
import Overrides from "#app/overrides";
import { EvolutionItem, FusionSpeciesFormEvolution, pokemonEvolutions } from "#balance/pokemon-evolutions";
import { FRIENDSHIP_GAIN_FROM_RARE_CANDY } from "#balance/starters";
import { tmPoolTiers, tmSpecies } from "#balance/tms";
import { allHeldItems, allMoves, allRewards, allTrainerItems } from "#data/data-lists";
import { getLevelTotalExp } from "#data/exp";
import { SpeciesFormChangeItemTrigger } from "#data/form-change-triggers";
import { getNatureName, getNatureStatMultiplier } from "#data/nature";
import { getPokeballCatchMultiplier, getPokeballName, MAX_PER_TYPE_POKEBALLS } from "#data/pokeball";
import { pokemonFormChanges, SpeciesFormChangeCondition } from "#data/pokemon-forms";
import { BattlerTagType } from "#enums/battler-tag-type";
import { BerryType } from "#enums/berry-type";
import { FormChangeItem } from "#enums/form-change-item";
import { HeldItemId } from "#enums/held-item-id";
import { LearnMoveType } from "#enums/learn-move-type";
import { MoveId } from "#enums/move-id";
import { Nature } from "#enums/nature";
import { PokeballType } from "#enums/pokeball";
import { PokemonType } from "#enums/pokemon-type";
import { RewardId } from "#enums/reward-id";
import { RewardPoolType } from "#enums/reward-pool-type";
import { RarityTier } from "#enums/reward-tier";
import { SpeciesFormKey } from "#enums/species-form-key";
import { SpeciesId } from "#enums/species-id";
import type { PermanentStat, TempBattleStat } from "#enums/stat";
import { Stat, TEMP_BATTLE_STATS } from "#enums/stat";
import { TrainerItemId } from "#enums/trainer-item-id";
import type { PlayerPokemon, Pokemon } from "#field/pokemon";
import { attackTypeToHeldItem } from "#items/attack-type-booster";
import { permanentStatToHeldItem, statBoostItems } from "#items/base-stat-booster";
import { berryTypeToHeldItem } from "#items/berry";
import { getNewAttackTypeBoosterHeldItem, getNewBerryHeldItem, getNewVitaminHeldItem } from "#items/held-item-pool";
import { formChangeItemName } from "#items/item-utility";
import {
  SPECIES_STAT_BOOSTER_ITEMS,
  type SpeciesStatBoosterItemId,
  type SpeciesStatBoostHeldItem,
} from "#items/stat-booster";
import { TrainerItemEffect, tempStatToTrainerItem } from "#items/trainer-item";
import type { PokemonMove } from "#moves/pokemon-move";
import { getVoucherTypeIcon, getVoucherTypeName, VoucherType } from "#system/voucher";
import type { RewardFunc, WeightedRewardWeightFunc } from "#types/rewards";
import type { Exact } from "#types/type-helpers";
import type { PokemonMoveSelectFilter, PokemonSelectFilter } from "#ui/party-ui-handler";
import { PartyUiHandler } from "#ui/party-ui-handler";
import { getRarityTierTextTint } from "#ui/text";
import {
  formatMoney,
  isNullOrUndefined,
  NumberHolder,
  padInt,
  pickWeightedIndex,
  randSeedInt,
  randSeedItem,
} from "#utils/common";
import { getEnumKeys, getEnumValues } from "#utils/enums";
import { getRewardPoolForType } from "#utils/reward-utils";
import i18next from "i18next";
import { getRewardDefaultTier } from "./reward-utils";

/*
The term "Reward" refers to items the player can access in the post-battle screen (although
they may be used in other places of the code as well).

Examples include (but are not limited to):
- Potions and other healing items
- Held items and trainer items
- Money items such as nugget and ancient relic

Rewards have a basic structure with a name, description, and icon. These are used to display
the reward in the reward select screen. All rewards have an .apply() method, which applies the
effect, for example:
- Apply healing to a pokemon
- Assign a held item to a pokemon, or a trainer item to the player
- Add money

Some rewards, once clicked, simply have their effect---these are Rewards that add money, pok√©ball,
vouchers, or global effect such as Sacred Ash.
Most rewards require extra parameters. They are divided into subclasses depending on the parameters
that they need, in particular:
- PokemonReward requires to pass a Pokemon (to apply healing, assign item...)
- PokemonMoveReward requires to pass a Pokemon and a move (for Elixir, or PP Up)
Plus some edge cases for Memory Mushroom and DNA Splicers.

The parameters to be passed are generated by the .applyReward() function in SelectRewardPhase.
This function takes care of opening the party screen and letting the player select a party pokemon,
a move, etc. depending on what is required. Once the parameters are generated, instead of calling
.apply() directly, we call the .applyReward() method in BattleScene, which also plays the sound.
[This method could perhaps be removed].

Rewards are assigned RewardId, and there are also RewardCategoryId. For example, TM is a RewardCategoryId,
while CommonTM, RareTM etc are RewardIds. There is _not_ a RewardId for _each_ move. Similarly,
some specific categories of held items are assigned their own RewardId, but they all fall under a single
RewardCategoryId.

rewardInitObj plays a similar role to allHeldItems, except instead of containing all possible reward
instances, it instead contains functions that generate those rewards. Here, the keys used are strings
rather than RewardId, the difference exists because here we want to distinguish unique held items
for example. The entries of rewardInitObj are used in the RewardPool.

There are some more derived classes, in particular:
RewardGenerator, which creates Reward instances from a certain group (e.g. TMs, nature mints, or berries);
WeightedReward, which is a Reward with an attached weight or weight function to be used in pools;
and RewardOption, which is displayed during the select reward phase at the end of each encounter.

This file still contains several functions to generate rewards from pools, which will need to be moved
to their own file. Some of those also need to be modified so that they can take a whole RewardPool in input.
This will allow more customization in creating pools for challenges, MEs etc.
*/

export abstract class Reward {
  // TODO: If all we care about for categorization is the reward's ID's _category_, why not do it there?
  // TODO: Make abstract and readonly
  public id: RewardId;
  public localeKey: string;
  public iconImage: string;
  public group: string; // TODO: Make a union type of all groups
  public soundName: string;
  public tier: RarityTier;

  constructor(localeKey: string | null, iconImage: string | null, group?: string, soundName?: string) {
    this.localeKey = localeKey!; // TODO: is this bang correct?
    this.iconImage = iconImage!; // TODO: is this bang correct?
    this.group = group!; // TODO: is this bang correct?
    this.soundName = soundName ?? "se/restore";
  }

  get name(): string {
    return i18next.t(`${this.localeKey}.name`);
  }

  getDescription(): string {
    return i18next.t(`${this.localeKey}.description`);
  }

  getIcon(): string {
    return this.iconImage;
  }

  // TODO: Should this be abstract?
  /**
   * Check whether this reward should be applied.
   */
  // TODO: This is erroring on stuff of typ
  shouldApply(_params: Exact<Parameters<this["apply"]>[0]>): boolean {
    return true;
  }

  /** Apply this Reward's effects. */
  // TODO: Remove `boolean` return from all superclasses' type signatures
  abstract apply(_params?: unknown): void;
}

// TODO: Can this return null?
// TODO: Make this generic based on T
type RewardGeneratorFunc<T extends Reward> = (party: Pokemon[], pregenArgs?: any[]) => T | null;

export abstract class RewardGenerator<T extends Reward = Reward> {
  private genRewardFunc: RewardGeneratorFunc<T>;
  public id: RewardId;

  constructor(genRewardFunc: RewardGeneratorFunc<T>) {
    this.genRewardFunc = genRewardFunc;
  }

  generateReward(party: Pokemon[], pregenArgs?: any[]) {
    const ret = this.genRewardFunc(party, pregenArgs);
    if (ret && this.id) {
      ret.id = this.id;
    }
    return ret;
  }
}

export class AddPokeballReward extends Reward {
  private pokeballType: PokeballType;
  private count: number;

  constructor(iconImage: string, pokeballType: PokeballType, count: number, id: RewardId) {
    super("", iconImage, "pb", "se/pb_bounce_1");
    this.pokeballType = pokeballType;
    this.count = count;
    this.id = id;
  }

  get name(): string {
    return i18next.t("modifierType:ModifierType.AddPokeballModifierType.name", {
      modifierCount: this.count,
      pokeballName: getPokeballName(this.pokeballType),
    });
  }

  getDescription(): string {
    return i18next.t("modifierType:ModifierType.AddPokeballModifierType.description", {
      modifierCount: this.count,
      pokeballName: getPokeballName(this.pokeballType),
      catchRate:
        getPokeballCatchMultiplier(this.pokeballType) > -1
          ? `${getPokeballCatchMultiplier(this.pokeballType)}x`
          : "100%",
      pokeballAmount: `${globalScene.pokeballCounts[this.pokeballType]}`,
    });
  }

  /**
   * Applies {@linkcode AddPokeballReward}
   * @returns always `true`
   */
  apply(): boolean {
    const pokeballCounts = globalScene.pokeballCounts;
    pokeballCounts[this.pokeballType] = Math.min(
      pokeballCounts[this.pokeballType] + this.count,
      MAX_PER_TYPE_POKEBALLS,
    );

    return true;
  }
}

export class AddVoucherReward extends Reward {
  private voucherType: VoucherType;
  private count: number;

  constructor(voucherType: VoucherType, count: number, id: RewardId) {
    super("", getVoucherTypeIcon(voucherType), "voucher");
    this.count = count;
    this.voucherType = voucherType;
    this.id = id;
  }

  get name(): string {
    return i18next.t("modifierType:ModifierType.AddVoucherConsumableType.name", {
      modifierCount: this.count,
      voucherTypeName: getVoucherTypeName(this.voucherType),
    });
  }

  getDescription(): string {
    return i18next.t("modifierType:ModifierType.AddVoucherConsumableType.description", {
      modifierCount: this.count,
      voucherTypeName: getVoucherTypeName(this.voucherType),
    });
  }

  /**
   * Applies {@linkcode AddVoucherReward}
   * @param battleScene {@linkcode BattleScene}
   * @returns always `true`
   */
  apply(): boolean {
    const voucherCounts = globalScene.gameData.voucherCounts;
    voucherCounts[this.voucherType] += this.count;

    return true;
  }
}

export class AddMoneyReward extends Reward {
  private moneyMultiplier: number;
  private moneyMultiplierDescriptorKey: string;

  constructor(
    localeKey: string,
    iconImage: string,
    moneyMultiplier: number,
    moneyMultiplierDescriptorKey: string,
    id: RewardId,
  ) {
    super(localeKey, iconImage, "money", "se/buy");

    this.moneyMultiplier = moneyMultiplier;
    this.moneyMultiplierDescriptorKey = moneyMultiplierDescriptorKey;
    this.id = id;
  }

  getDescription(): string {
    const moneyAmount = new NumberHolder(globalScene.getWaveMoneyAmount(this.moneyMultiplier));
    globalScene.applyPlayerItems(TrainerItemEffect.MONEY_MULTIPLIER, { numberHolder: moneyAmount });
    const formattedMoney = formatMoney(globalScene.moneyFormat, moneyAmount.value);

    return i18next.t("modifierType:ModifierType.MoneyRewardModifierType.description", {
      moneyMultiplier: i18next.t(this.moneyMultiplierDescriptorKey as any),
      moneyAmount: formattedMoney,
    });
  }

  /**
   * Applies {@linkcode AddMoneyReward}
   * @returns always `true`
   */
  apply(): boolean {
    const moneyAmount = new NumberHolder(globalScene.getWaveMoneyAmount(this.moneyMultiplier));

    globalScene.applyPlayerItems(TrainerItemEffect.MONEY_MULTIPLIER, { numberHolder: moneyAmount });

    globalScene.addMoney(moneyAmount.value);

    for (const p of globalScene.getPlayerParty()) {
      if (p.hasSpecies(SpeciesId.GIMMIGHOUL)) {
        const factor = Math.min(Math.floor(this.moneyMultiplier), 3);
        p.heldItemManager.add(HeldItemId.GIMMIGHOUL_EVO_TRACKER, factor);
      }
    }

    return true;
  }
}

/** Rewards that are applied to individual Pokemon. */
export abstract class PokemonReward extends Reward {
  public selectFilter: PokemonSelectFilter | undefined;

  constructor(
    localeKey: string,
    iconImage: string,
    selectFilter?: PokemonSelectFilter,
    group?: string,
    soundName?: string,
  ) {
    super(localeKey, iconImage, group, soundName);
    this.selectFilter = selectFilter;
  }

  abstract override apply(_params: PokemonRewardParams): void;
}

export interface PokemonRewardParams {
  pokemon: PlayerPokemon;
}

export interface PokemonMoveRewardParams {
  pokemon: PlayerPokemon;
  moveIndex: number;
}

export interface PokemonMoveRecallRewardParams {
  pokemon: PlayerPokemon;
  moveIndex: number;
  cost?: number;
}

export interface PokemonFusionRewardParams {
  pokemon: PlayerPokemon;
  pokemon2: PlayerPokemon;
}

export class HeldItemReward extends PokemonReward {
  public itemId: HeldItemId;
  constructor(itemId: HeldItemId, group?: string, soundName?: string) {
    super(
      "",
      "",
      (pokemon: PlayerPokemon) => {
        const hasItem = pokemon.heldItemManager.hasItem(this.itemId);
        const maxStackCount = allHeldItems[this.itemId].getMaxStackCount();
        if (!maxStackCount) {
          return i18next.t("modifierType:ModifierType.PokemonHeldItemModifierType.extra.inoperable", {
            pokemonName: getPokemonNameWithAffix(pokemon),
          });
        }
        if (hasItem && pokemon.heldItemManager.getStack(this.itemId) === maxStackCount) {
          return i18next.t("modifierType:ModifierType.PokemonHeldItemModifierType.extra.tooMany", {
            pokemonName: getPokemonNameWithAffix(pokemon),
          });
        }
        return null;
      },
      group,
      soundName,
    );
    this.itemId = itemId;
    this.id = RewardId.HELD_ITEM;
  }

  get name(): string {
    return allHeldItems[this.itemId].name;
  }

  getDescription(): string {
    return allHeldItems[this.itemId].description;
  }

  getIcon(): string {
    return allHeldItems[this.itemId].iconName;
  }

  apply({ pokemon }: PokemonRewardParams): boolean {
    return pokemon.heldItemManager.add(this.itemId);
  }
}

export class TrainerItemReward extends Reward {
  public itemId: TrainerItemId;
  constructor(itemId: TrainerItemId, group?: string, soundName?: string) {
    super("", "", group, soundName);
    this.itemId = itemId;
    this.id = RewardId.TRAINER_ITEM;
  }

  get name(): string {
    return allTrainerItems[this.itemId].name;
  }

  getDescription(): string {
    return allTrainerItems[this.itemId].description;
  }

  getIcon(): string {
    return allTrainerItems[this.itemId].iconName;
  }

  apply(): boolean {
    return globalScene.trainerItems.add(this.itemId);
  }
}

export class LapsingTrainerItemReward extends TrainerItemReward {
  constructor(itemId: TrainerItemId, id?: RewardId) {
    super(itemId);
    this.id = id ?? RewardId.TRAINER_ITEM;
  }

  apply(): boolean {
    return globalScene.trainerItems.add(this.itemId, allTrainerItems[this.itemId].getMaxStackCount());
  }
}

export class ChangeTeraTypeReward extends PokemonReward {
  private teraType: PokemonType;

  constructor(teraType: PokemonType) {
    super(
      "",
      `${PokemonType[teraType].toLowerCase()}_tera_shard`,
      (pokemon: PlayerPokemon) => {
        if (
          [pokemon.species.speciesId, pokemon.fusionSpecies?.speciesId].filter(
            s => s === SpeciesId.TERAPAGOS || s === SpeciesId.OGERPON || s === SpeciesId.SHEDINJA,
          ).length > 0
        ) {
          return PartyUiHandler.NoEffectMessage;
        }
        return null;
      },
      "tera_shard",
    );

    this.teraType = teraType;
  }

  get name(): string {
    return i18next.t("modifierType:ModifierType.ChangeTeraTypeModifierType.name", {
      teraType: i18next.t(`pokemonInfo:Type.${PokemonType[this.teraType]}`),
    });
  }

  getDescription(): string {
    return i18next.t("modifierType:ModifierType.ChangeTeraTypeModifierType.description", {
      teraType: i18next.t(`pokemonInfo:Type.${PokemonType[this.teraType]}`),
    });
  }

  getPregenArgs(): any[] {
    return [this.teraType];
  }

  /**
   * Checks if {@linkcode TerrastalizeConsumable} should be applied
   * @param playerPokemon The {@linkcode PlayerPokemon} that consumes the item
   * @returns `true` if the {@linkcode TerrastalizeConsumable} should be applied
   */
  shouldApply({ pokemon }: PokemonRewardParams): boolean {
    return (
      pokemon.teraType !== this.teraType &&
      ![SpeciesId.SHEDINJA, SpeciesId.OGERPON, SpeciesId.TERAPAGOS].some(s => pokemon.hasSpecies(s))
    );
  }

  /**
   * Applies {@linkcode TerrastalizeConsumable}
   * @param pokemon The {@linkcode PlayerPokemon} that consumes the item
   * @returns `true` if hp was restored
   */
  apply({ pokemon }: PokemonRewardParams): boolean {
    pokemon.teraType = this.teraType;
    return true;
  }
}

function restorePokemonHp(
  pokemon: Pokemon,
  percentToRestore: number,
  pointsToRestore = 0,
  healStatus = false,
  fainted = false,
): boolean {
  if (!pokemon.hp === fainted) {
    if (fainted || healStatus) {
      pokemon.resetStatus(true, true, false, false);
    }
    // Apply HealingCharm
    let multiplier = 1;
    if (!fainted) {
      const hpRestoreMultiplier = new NumberHolder(1);
      this.applyPlayerItems(TrainerItemEffect.HEALING_BOOSTER, { numberHolder: hpRestoreMultiplier });
      multiplier = hpRestoreMultiplier.value;
    }
    const restorePoints = Math.floor(pointsToRestore * multiplier);
    const restorePercent = Math.floor(percentToRestore * 0.01 * multiplier * pokemon.getMaxHp());
    pokemon.heal(Math.max(restorePercent, restorePoints, 1));
    return true;
  }
  return false;
}

export class PokemonHpRestoreReward extends PokemonReward {
  protected restorePoints: number;
  protected restorePercent: number;
  protected healStatus: boolean;

  constructor(
    localeKey: string,
    iconImage: string,
    id: RewardId,
    restorePoints: number,
    restorePercent: number,
    healStatus = false,
    selectFilter?: PokemonSelectFilter,
    group?: string,
  ) {
    super(
      localeKey,
      iconImage,
      selectFilter ||
        ((pokemon: PlayerPokemon) => {
          if (
            !pokemon.hp ||
            (pokemon.isFullHp() && (!this.healStatus || (!pokemon.status && !pokemon.getTag(BattlerTagType.CONFUSED))))
          ) {
            return PartyUiHandler.NoEffectMessage;
          }
          return null;
        }),
      group || "potion",
    );

    this.restorePoints = restorePoints;
    this.restorePercent = restorePercent;
    this.healStatus = healStatus;
    this.id = id;
  }

  getDescription(): string {
    return this.restorePoints
      ? i18next.t("modifierType:ModifierType.PokemonHpRestoreModifierType.description", {
          restorePoints: this.restorePoints,
          restorePercent: this.restorePercent,
        })
      : this.healStatus
        ? i18next.t("modifierType:ModifierType.PokemonHpRestoreModifierType.extra.fullyWithStatus")
        : i18next.t("modifierType:ModifierType.PokemonHpRestoreModifierType.extra.fully");
  }

  apply({ pokemon }: PokemonRewardParams): boolean {
    return restorePokemonHp(pokemon, this.restorePercent, this.restorePoints, this.healStatus, false);
  }
}

export class PokemonReviveReward extends PokemonHpRestoreReward {
  constructor(localeKey: string, iconImage: string, id: RewardId, restorePercent: number) {
    super(
      localeKey,
      iconImage,
      id,
      0,
      restorePercent,
      false,
      (pokemon: PlayerPokemon) => {
        if (!pokemon.isFainted()) {
          return PartyUiHandler.NoEffectMessage;
        }
        return null;
      },
      "revive",
    );

    this.selectFilter = (pokemon: PlayerPokemon) => {
      if (pokemon.hp) {
        return PartyUiHandler.NoEffectMessage;
      }
      return null;
    };
  }

  getDescription(): string {
    return i18next.t("modifierType:ModifierType.PokemonReviveModifierType.description", {
      restorePercent: this.restorePercent,
    });
  }

  apply({ pokemon }: PokemonRewardParams): boolean {
    return restorePokemonHp(pokemon, this.restorePercent, 0, false, true);
  }
}

class AllPokemonFullReviveReward extends Reward {
  constructor(localeKey: string, iconImage: string) {
    super(localeKey, iconImage, "modifierType:ModifierType.AllPokemonFullReviveModifierType");
    this.id = RewardId.SACRED_ASH;
  }

  apply(): boolean {
    for (const pokemon of globalScene.getPlayerParty()) {
      restorePokemonHp(pokemon, 100, 0, false, true);
    }

    return true;
  }
}

export class PokemonStatusHealReward extends PokemonReward {
  constructor(localeKey: string, iconImage: string) {
    super(localeKey, iconImage, (pokemon: PlayerPokemon) => {
      if (!pokemon.hp || (!pokemon.status && !pokemon.getTag(BattlerTagType.CONFUSED))) {
        return PartyUiHandler.NoEffectMessage;
      }
      return null;
    });
    this.id = RewardId.FULL_HEAL;
  }

  getDescription(): string {
    return i18next.t("modifierType:ModifierType.PokemonStatusHealModifierType.description");
  }

  apply({ pokemon }: PokemonRewardParams): boolean {
    pokemon.resetStatus(true, true, false, false);
    return true;
  }
}

export abstract class PokemonMoveReward extends PokemonReward {
  public moveSelectFilter: PokemonMoveSelectFilter | undefined;

  constructor(
    localeKey: string,
    iconImage: string,
    id: RewardId,
    selectFilter?: PokemonSelectFilter,
    moveSelectFilter?: PokemonMoveSelectFilter,
    group?: string,
  ) {
    super(localeKey, iconImage, selectFilter, group);
    this.moveSelectFilter = moveSelectFilter;
    this.id = id;
  }

  apply(_params: PokemonMoveRewardParams): boolean {
    return false;
  }
}

export class PokemonPpRestoreReward extends PokemonMoveReward {
  protected restorePoints: number;

  constructor(localeKey: string, iconImage: string, id: RewardId, restorePoints: number) {
    super(
      localeKey,
      iconImage,
      id,
      (_pokemon: PlayerPokemon) => {
        return null;
      },
      (pokemonMove: PokemonMove) => {
        if (!pokemonMove.ppUsed) {
          return PartyUiHandler.NoEffectMessage;
        }
        return null;
      },
      "ether",
    );

    this.restorePoints = restorePoints;
  }

  getDescription(): string {
    return this.restorePoints > -1
      ? i18next.t("modifierType:ModifierType.PokemonPpRestoreModifierType.description", {
          restorePoints: this.restorePoints,
        })
      : i18next.t("modifierType:ModifierType.PokemonPpRestoreModifierType.extra.fully");
  }

  /**
   * Applies {@linkcode PokemonPpRestoreConsumable}
   * @param playerPokemon The {@linkcode PlayerPokemon} that should get move pp restored
   * @returns always `true`
   */
  apply({ pokemon, moveIndex }: PokemonMoveRewardParams): boolean {
    const move = pokemon.getMoveset()[moveIndex];

    if (move) {
      move.ppUsed = this.restorePoints > -1 ? Math.max(move.ppUsed - this.restorePoints, 0) : 0;
    }

    return true;
  }
}

export class PokemonAllMovePpRestoreReward extends PokemonReward {
  protected restorePoints: number;

  constructor(localeKey: string, iconImage: string, id: RewardId, restorePoints: number) {
    super(
      localeKey,
      iconImage,
      (pokemon: PlayerPokemon) => {
        if (!pokemon.getMoveset().filter(m => m.ppUsed).length) {
          return PartyUiHandler.NoEffectMessage;
        }
        return null;
      },
      "elixir",
    );

    this.restorePoints = restorePoints;
    this.id = id;
  }

  getDescription(): string {
    return this.restorePoints > -1
      ? i18next.t("modifierType:ModifierType.PokemonAllMovePpRestoreModifierType.description", {
          restorePoints: this.restorePoints,
        })
      : i18next.t("modifierType:ModifierType.PokemonAllMovePpRestoreModifierType.extra.fully");
  }

  /**
   * Applies {@linkcode PokemonAllMovePpRestoreConsumable}
   * @param playerPokemon The {@linkcode PlayerPokemon} that should get all move pp restored
   * @returns always `true`
   */
  apply({ pokemon }: PokemonRewardParams): boolean {
    for (const move of pokemon.getMoveset()) {
      if (move) {
        move.ppUsed = this.restorePoints > -1 ? Math.max(move.ppUsed - this.restorePoints, 0) : 0;
      }
    }

    return true;
  }
}

export class PokemonPpUpReward extends PokemonMoveReward {
  protected upPoints: number;

  constructor(localeKey: string, iconImage: string, id: RewardId, upPoints: number) {
    super(
      localeKey,
      iconImage,
      id,
      (_pokemon: PlayerPokemon) => {
        return null;
      },
      (pokemonMove: PokemonMove) => {
        if (pokemonMove.getMove().pp < 5 || pokemonMove.ppUp >= 3 || pokemonMove.maxPpOverride) {
          return PartyUiHandler.NoEffectMessage;
        }
        return null;
      },
      "ppUp",
    );

    this.upPoints = upPoints;
  }

  getDescription(): string {
    return i18next.t("modifierType:ModifierType.PokemonPpUpModifierType.description", { upPoints: this.upPoints });
  }

  /**
   * Applies {@linkcode PokemonPpUpConsumable}
   * @param playerPokemon The {@linkcode PlayerPokemon} that gets a pp up on move-slot {@linkcode moveIndex}
   * @returns
   */
  apply({ pokemon, moveIndex }: PokemonMoveRewardParams): boolean {
    const move = pokemon.getMoveset()[moveIndex];

    if (move && !move.maxPpOverride) {
      move.ppUp = Math.min(move.ppUp + this.upPoints, 3);
    }

    return true;
  }
}

export class PokemonNatureChangeReward extends PokemonReward {
  protected nature: Nature;

  constructor(nature: Nature) {
    super(
      "",
      `mint_${
        getEnumKeys(Stat)
          .find(s => getNatureStatMultiplier(nature, Stat[s]) > 1)
          ?.toLowerCase() || "neutral"
      }`,
      (pokemon: PlayerPokemon) => {
        if (pokemon.getNature() === this.nature) {
          return PartyUiHandler.NoEffectMessage;
        }
        return null;
      },
      "mint",
    );

    this.nature = nature;
    this.id = RewardId.MINT;
  }

  get name(): string {
    return i18next.t("modifierType:ModifierType.PokemonNatureChangeModifierType.name", {
      natureName: getNatureName(this.nature),
    });
  }

  getDescription(): string {
    return i18next.t("modifierType:ModifierType.PokemonNatureChangeModifierType.description", {
      natureName: getNatureName(this.nature, true, true, true),
    });
  }

  /**
   * Applies {@linkcode PokemonNatureChangeConsumable}
   * @param playerPokemon {@linkcode PlayerPokemon} to apply the {@linkcode Nature} change to
   * @returns
   */
  apply({ pokemon }: PokemonRewardParams): boolean {
    pokemon.setCustomNature(this.nature);
    globalScene.gameData.unlockSpeciesNature(pokemon.species, this.nature);

    return true;
  }
}

export class RememberMoveReward extends PokemonReward {
  constructor(localeKey: string, iconImage: string, group?: string) {
    super(
      localeKey,
      iconImage,
      (pokemon: PlayerPokemon) => {
        if (!pokemon.getLearnableLevelMoves().length) {
          return PartyUiHandler.NoEffectMessage;
        }
        return null;
      },
      group,
    );
    this.id = RewardId.MEMORY_MUSHROOM;
  }

  /**
   * Applies {@linkcode RememberMoveConsumable}
   * @param playerPokemon The {@linkcode PlayerPokemon} that should remember the move
   * @returns always `true`
   */
  apply({ pokemon, moveIndex, cost }: PokemonMoveRecallRewardParams): boolean {
    globalScene.phaseManager.unshiftNew(
      "LearnMovePhase",
      globalScene.getPlayerParty().indexOf(pokemon as PlayerPokemon),
      pokemon.getLearnableLevelMoves()[moveIndex],
      LearnMoveType.MEMORY,
      cost,
    );

    return true;
  }
}

class BerryRewardGenerator extends RewardGenerator {
  constructor() {
    super((_party: Pokemon[], pregenArgs?: any[]) => {
      if (pregenArgs && pregenArgs.length === 1 && pregenArgs[0] in BerryType) {
        const item = berryTypeToHeldItem[pregenArgs[0] as BerryType];
        return new HeldItemReward(item);
      }
      const item = getNewBerryHeldItem();
      return new HeldItemReward(item);
    });
    this.id = RewardId.BERRY;
  }
}

class MintRewardGenerator extends RewardGenerator {
  constructor() {
    super((_party: Pokemon[], pregenArgs?: any[]) => {
      if (pregenArgs && pregenArgs.length === 1 && pregenArgs[0] in Nature) {
        return new PokemonNatureChangeReward(pregenArgs[0] as Nature);
      }
      return new PokemonNatureChangeReward(randSeedItem(getEnumValues(Nature)));
    });
    this.id = RewardId.MINT;
  }
}

class TeraTypeRewardGenerator extends RewardGenerator {
  constructor() {
    super((party: Pokemon[], pregenArgs?: any[]) => {
      if (pregenArgs && pregenArgs.length === 1 && pregenArgs[0] in PokemonType) {
        return new ChangeTeraTypeReward(pregenArgs[0] as PokemonType);
      }
      if (!globalScene.trainerItems.hasItem(TrainerItemId.TERA_ORB)) {
        return null;
      }
      const teraTypes: PokemonType[] = [];
      for (const p of party) {
        if (
          !(p.hasSpecies(SpeciesId.TERAPAGOS) || p.hasSpecies(SpeciesId.OGERPON) || p.hasSpecies(SpeciesId.SHEDINJA))
        ) {
          teraTypes.push(p.teraType);
        }
      }
      let excludedType = PokemonType.UNKNOWN;
      if (teraTypes.length > 0 && teraTypes.filter(t => t === teraTypes[0]).length === teraTypes.length) {
        excludedType = teraTypes[0];
      }
      let shardType = randSeedInt(64) ? (randSeedInt(18) as PokemonType) : PokemonType.STELLAR;
      while (shardType === excludedType) {
        shardType = randSeedInt(64) ? (randSeedInt(18) as PokemonType) : PokemonType.STELLAR;
      }
      return new ChangeTeraTypeReward(shardType);
    });
    this.id = RewardId.TERA_SHARD;
  }
}

export class AttackTypeBoosterReward extends HeldItemReward {
  public moveType: PokemonType;
  public boostPercent: number;

  constructor(moveType: PokemonType, boostPercent: number) {
    const itemId = attackTypeToHeldItem[moveType];
    super(itemId);
    this.moveType = moveType;
    this.boostPercent = boostPercent;
  }

  getPregenArgs(): any[] {
    return [this.moveType];
  }
}

function incrementLevelWithCandy(pokemon: Pokemon): boolean {
  const levelCount = new NumberHolder(1);
  globalScene.applyPlayerItems(TrainerItemEffect.LEVEL_INCREMENT_BOOSTER, { numberHolder: levelCount });

  pokemon.level += levelCount.value;
  if (pokemon.level <= globalScene.getMaxExpLevel(true)) {
    pokemon.exp = getLevelTotalExp(pokemon.level, pokemon.species.growthRate);
    pokemon.levelExp = 0;
  }

  if (pokemon.isPlayer()) {
    pokemon.addFriendship(FRIENDSHIP_GAIN_FROM_RARE_CANDY);

    globalScene.phaseManager.unshiftNew(
      "LevelUpPhase",
      globalScene.getPlayerParty().indexOf(pokemon),
      pokemon.level - levelCount.value,
      pokemon.level,
    );
  }
  return true;
}

export class PokemonLevelIncrementReward extends PokemonReward {
  constructor(localeKey: string, iconImage: string) {
    super(localeKey, iconImage, (_pokemon: PlayerPokemon) => null);
    this.id = RewardId.RARE_CANDY;
  }

  getDescription(): string {
    let levels = 1;
    const candyJarStack = globalScene.trainerItems.getStack(TrainerItemId.CANDY_JAR);
    levels += candyJarStack;
    return i18next.t("modifierType:ModifierType.PokemonLevelIncrementModifierType.description", { levels });
  }

  /**
   * Applies {@linkcode PokemonLevelIncrementConsumable}
   * @param playerPokemon The {@linkcode PlayerPokemon} that should get levels incremented
   * @param levelCount The amount of levels to increment
   * @returns always `true`
   */
  apply({ pokemon }: PokemonRewardParams): boolean {
    return incrementLevelWithCandy(pokemon);
  }
}

export class AllPokemonLevelIncrementReward extends Reward {
  id = RewardId.RARER_CANDY;

  getDescription(): string {
    let levels = 1;
    const candyJarStack = globalScene.trainerItems.getStack(TrainerItemId.CANDY_JAR);
    levels += candyJarStack;
    return i18next.t("modifierType:ModifierType.AllPokemonLevelIncrementModifierType.description", { levels });
  }

  apply(): boolean {
    for (const pokemon of globalScene.getPlayerParty()) {
      incrementLevelWithCandy(pokemon);
    }

    return true;
  }
}

export class BaseStatBoosterReward extends HeldItemReward {
  private stat: PermanentStat;
  private key: string;

  constructor(stat: PermanentStat) {
    const key = statBoostItems[stat];
    const itemId = permanentStatToHeldItem[stat];
    super(itemId);

    this.stat = stat;
    this.key = key;
  }
}

export class TmReward extends PokemonReward {
  public moveId: MoveId;

  constructor(moveId: MoveId) {
    super(
      "",
      `tm_${PokemonType[allMoves[moveId].type].toLowerCase()}`,
      (pokemon: PlayerPokemon) => {
        if (
          pokemon.compatibleTms.indexOf(moveId) === -1 ||
          pokemon.getMoveset().filter(m => m.moveId === moveId).length
        ) {
          return PartyUiHandler.NoEffectMessage;
        }
        return null;
      },
      "tm",
    );

    this.moveId = moveId;
  }

  get name(): string {
    return i18next.t("modifierType:ModifierType.TmModifierType.name", {
      moveId: padInt(Object.keys(tmSpecies).indexOf(this.moveId.toString()) + 1, 3),
      moveName: allMoves[this.moveId].name,
    });
  }

  getDescription(): string {
    return i18next.t(
      globalScene.enableMoveInfo
        ? "modifierType:ModifierType.TmModifierTypeWithInfo.description"
        : "modifierType:ModifierType.TmModifierType.description",
      { moveName: allMoves[this.moveId].name },
    );
  }

  /**
   * Applies {@linkcode TmConsumable}
   * @param playerPokemon The {@linkcode PlayerPokemon} that should learn the TM
   * @returns always `true`
   */
  apply({ pokemon }: PokemonRewardParams): boolean {
    globalScene.phaseManager.unshiftNew(
      "LearnMovePhase",
      globalScene.getPlayerParty().indexOf(pokemon),
      this.moveId,
      LearnMoveType.TM,
    );

    return true;
  }
}

export class EvolutionItemReward extends PokemonReward {
  public evolutionItem: EvolutionItem;

  constructor(evolutionItem: EvolutionItem) {
    super("", EvolutionItem[evolutionItem].toLowerCase(), (pokemon: PlayerPokemon) => {
      if (
        pokemonEvolutions.hasOwnProperty(pokemon.species.speciesId) &&
        pokemonEvolutions[pokemon.species.speciesId].filter(e => e.validate(pokemon, false, this.evolutionItem))
          .length &&
        pokemon.getFormKey() !== SpeciesFormKey.GIGANTAMAX
      ) {
        return null;
      }
      if (
        pokemon.isFusion() &&
        pokemon.fusionSpecies &&
        pokemonEvolutions.hasOwnProperty(pokemon.fusionSpecies.speciesId) &&
        pokemonEvolutions[pokemon.fusionSpecies.speciesId].filter(e => e.validate(pokemon, true, this.evolutionItem))
          .length &&
        pokemon.getFusionFormKey() !== SpeciesFormKey.GIGANTAMAX
      ) {
        return null;
      }

      return PartyUiHandler.NoEffectMessage;
    });

    this.evolutionItem = evolutionItem;
  }

  get name(): string {
    return i18next.t(`modifierType:EvolutionItem.${EvolutionItem[this.evolutionItem]}`);
  }

  getDescription(): string {
    return i18next.t("modifierType:ModifierType.EvolutionItemModifierType.description");
  }

  getPregenArgs(): any[] {
    return [this.evolutionItem];
  }

  /**
   * Applies {@linkcode EvolutionItemConsumable}
   * @param playerPokemon The {@linkcode PlayerPokemon} that should evolve via item
   * @returns `true` if the evolution was successful
   */
  apply({ pokemon }: PokemonRewardParams): boolean {
    let matchingEvolution = pokemonEvolutions.hasOwnProperty(pokemon.species.speciesId)
      ? pokemonEvolutions[pokemon.species.speciesId].find(
          e => e.evoItem === this.evolutionItem && e.validate(pokemon, false, e.item!),
        )
      : null;

    if (!matchingEvolution && pokemon.isFusion()) {
      matchingEvolution = pokemonEvolutions[pokemon.fusionSpecies!.speciesId].find(
        e => e.evoItem === this.evolutionItem && e.validate(pokemon, true, e.item!),
      );
      if (matchingEvolution) {
        matchingEvolution = new FusionSpeciesFormEvolution(pokemon.species.speciesId, matchingEvolution);
      }
    }

    if (matchingEvolution) {
      globalScene.phaseManager.unshiftNew("EvolutionPhase", pokemon, matchingEvolution, pokemon.level - 1);
      return true;
    }

    return false;
  }
}

/**
 * Class that represents form changing items
 */
export class FormChangeItemReward extends PokemonReward {
  public formChangeItem: FormChangeItem;

  constructor(formChangeItem: FormChangeItem) {
    super("", FormChangeItem[formChangeItem].toLowerCase(), (pokemon: PlayerPokemon) => {
      // Make sure the Pokemon has alternate forms
      if (
        pokemonFormChanges.hasOwnProperty(pokemon.species.speciesId) &&
        // Get all form changes for this species with an item trigger, including any compound triggers
        pokemonFormChanges[pokemon.species.speciesId]
          .filter(
            fc => fc.trigger.hasTriggerType(SpeciesFormChangeItemTrigger) && fc.preFormKey === pokemon.getFormKey(),
          )
          // Returns true if any form changes match this item
          .flatMap(fc => fc.findTrigger(SpeciesFormChangeItemTrigger) as SpeciesFormChangeItemTrigger)
          .flatMap(fc => fc.item)
          .includes(this.formChangeItem)
      ) {
        return null;
      }

      return PartyUiHandler.NoEffectMessage;
    });

    this.formChangeItem = formChangeItem;
    this.id = RewardId.FORM_CHANGE_ITEM;
  }

  get name(): string {
    return formChangeItemName(this.formChangeItem);
  }

  getDescription(): string {
    return i18next.t("modifierType:ModifierType.FormChangeItemModifierType.description");
  }

  apply({ pokemon }: PokemonRewardParams): boolean {
    if (pokemon.heldItemManager.hasFormChangeItem(this.formChangeItem)) {
      return false;
    }

    pokemon.heldItemManager.addFormChangeItem(this.formChangeItem);
    pokemon.heldItemManager.toggleActive(this.formChangeItem);

    globalScene.triggerPokemonFormChange(pokemon, SpeciesFormChangeItemTrigger);

    globalScene.updateItems(true);

    return true;
  }
}

export class FusePokemonReward extends PokemonReward {
  constructor(localeKey: string, iconImage: string) {
    super(localeKey, iconImage, (pokemon: PlayerPokemon) => {
      if (pokemon.isFusion()) {
        return PartyUiHandler.NoEffectMessage;
      }
      return null;
    });
    this.id = RewardId.DNA_SPLICERS;
  }

  getDescription(): string {
    return i18next.t("modifierType:ModifierType.FusePokemonModifierType.description");
  }

  /**
   * Applies {@linkcode FusePokemonConsumable}
   * @param playerPokemon {@linkcode PlayerPokemon} that should be fused
   * @param playerPokemon2 {@linkcode PlayerPokemon} that should be fused with {@linkcode playerPokemon}
   * @returns always Promise<true>
   */
  apply({ pokemon, pokemon2 }: PokemonFusionRewardParams): boolean {
    pokemon.fuse(pokemon2);
    return true;
  }
}

class AttackTypeBoosterRewardGenerator extends RewardGenerator {
  constructor() {
    super((party: Pokemon[], pregenArgs?: any[]) => {
      if (pregenArgs && pregenArgs.length === 1 && pregenArgs[0] in PokemonType) {
        return new AttackTypeBoosterReward(pregenArgs[0] as PokemonType, TYPE_BOOST_ITEM_BOOST_PERCENT);
      }

      const item = getNewAttackTypeBoosterHeldItem(party);

      return item ? new HeldItemReward(item) : null;
    });
    this.id = RewardId.ATTACK_TYPE_BOOSTER;
  }
}

class BaseStatBoosterRewardGenerator extends RewardGenerator {
  constructor() {
    super((_party: Pokemon[], pregenArgs?: any[]) => {
      if (pregenArgs) {
        return new BaseStatBoosterReward(pregenArgs[0]);
      }
      return new HeldItemReward(getNewVitaminHeldItem());
    });
    this.id = RewardId.BASE_STAT_BOOSTER;
  }
}

class TempStatStageBoosterRewardGenerator extends RewardGenerator {
  public static readonly items: Record<TempBattleStat, string> = {
    [Stat.ATK]: "x_attack",
    [Stat.DEF]: "x_defense",
    [Stat.SPATK]: "x_sp_atk",
    [Stat.SPDEF]: "x_sp_def",
    [Stat.SPD]: "x_speed",
    [Stat.ACC]: "x_accuracy",
  };

  constructor() {
    super((_party: Pokemon[], pregenArgs?: any[]) => {
      if (pregenArgs && pregenArgs.length === 1 && TEMP_BATTLE_STATS.includes(pregenArgs[0])) {
        return new LapsingTrainerItemReward(tempStatToTrainerItem[pregenArgs[0]]);
      }
      const randStat: TempBattleStat = randSeedInt(Stat.ACC, Stat.ATK);
      return new LapsingTrainerItemReward(tempStatToTrainerItem[randStat]);
    });
    this.id = RewardId.TEMP_STAT_STAGE_BOOSTER;
  }
}

/**
 * Consumable type generator for {@linkcode SpeciesStatBoosterReward}, which
 * encapsulates the logic for weighting the most useful held item from
 * the current list of {@linkcode items}.
 * @extends RewardGenerator
 */
class SpeciesStatBoosterRewardGenerator extends RewardGenerator {
  /** Object comprised of the currently available species-based stat boosting held items */

  constructor(rare: boolean) {
    super((party: Pokemon[], pregenArgs?: any[]) => {
      if (pregenArgs && pregenArgs.length === 1 && pregenArgs[0] in SPECIES_STAT_BOOSTER_ITEMS) {
        return new HeldItemReward(pregenArgs[0] as HeldItemId);
      }

      // Get a pool of items based on the rarity.
      const tierItems = rare
        ? [HeldItemId.LIGHT_BALL, HeldItemId.THICK_CLUB, HeldItemId.METAL_POWDER, HeldItemId.QUICK_POWDER]
        : [HeldItemId.DEEP_SEA_SCALE, HeldItemId.DEEP_SEA_TOOTH];

      const weights = new Array(tierItems.length).fill(0);

      for (const p of party) {
        const speciesId = p.getSpeciesForm(true).speciesId;
        const fusionSpeciesId = p.isFusion() ? p.getFusionSpeciesForm(true).speciesId : null;
        // TODO: Use commented boolean when Fling is implemented
        const hasFling = false; /* p.getMoveset(true).some(m => m.moveId === MoveId.FLING) */

        for (const i in tierItems) {
          const checkedSpecies = (allHeldItems[tierItems[i]] as SpeciesStatBoostHeldItem).species;

          // If party member already has the item being weighted currently, skip to the next item
          const hasItem = p.heldItemManager.hasItem(tierItems[i]);

          if (!hasItem) {
            if (checkedSpecies.includes(speciesId) || (!!fusionSpeciesId && checkedSpecies.includes(fusionSpeciesId))) {
              // Add weight if party member has a matching species or, if applicable, a matching fusion species
              weights[i]++;
            } else if (checkedSpecies.includes(SpeciesId.PIKACHU) && hasFling) {
              // Add weight to Light Ball if party member has Fling
              weights[i]++;
            }
          }
        }
      }

      // TODO: Replace this with a helper function
      let totalWeight = 0;
      for (const weight of weights) {
        totalWeight += weight;
      }

      if (totalWeight !== 0) {
        const randInt = randSeedInt(totalWeight, 1);
        let weight = 0;

        for (const i in weights) {
          if (weights[i] !== 0) {
            const curWeight = weight + weights[i];
            if (randInt <= weight + weights[i]) {
              return new HeldItemReward(tierItems[i]);
            }
            weight = curWeight;
          }
        }
      }

      return null;
    });
    this.id = rare ? RewardId.SPECIES_STAT_BOOSTER : RewardId.RARE_SPECIES_STAT_BOOSTER;
  }
}

class TmRewardGenerator extends RewardGenerator {
  constructor(tier: RarityTier) {
    super((party: Pokemon[], pregenArgs?: any[]) => {
      if (pregenArgs && pregenArgs.length === 1 && pregenArgs[0] in MoveId) {
        return new TmReward(pregenArgs[0] as MoveId);
      }
      const partyMemberCompatibleTms = party.map(p => {
        const previousLevelMoves = p.getLearnableLevelMoves();
        return (p as PlayerPokemon).compatibleTms.filter(
          tm => !p.moveset.find(m => m.moveId === tm) && !previousLevelMoves.find(lm => lm === tm),
        );
      });
      const tierUniqueCompatibleTms = partyMemberCompatibleTms
        .flat()
        .filter(tm => tmPoolTiers[tm] === tier)
        .filter(tm => !allMoves[tm].name.endsWith(" (N)"))
        .filter((tm, i, array) => array.indexOf(tm) === i);
      if (!tierUniqueCompatibleTms.length) {
        return null;
      }
      // TODO: should this use `randSeedItem`?
      const randTmIndex = randSeedInt(tierUniqueCompatibleTms.length);
      return new TmReward(tierUniqueCompatibleTms[randTmIndex]);
    });
    this.id =
      tier === RarityTier.COMMON
        ? RewardId.TM_COMMON
        : tier === RarityTier.GREAT
          ? RewardId.TM_GREAT
          : RewardId.TM_ULTRA;
  }
}

class EvolutionItemRewardGenerator extends RewardGenerator {
  constructor(rare: boolean, id: RewardId) {
    super((party: Pokemon[], pregenArgs?: any[]) => {
      if (pregenArgs && pregenArgs.length === 1 && pregenArgs[0] in EvolutionItem) {
        return new EvolutionItemReward(pregenArgs[0] as EvolutionItem);
      }

      const evolutionItemPool = [
        party
          .filter(
            p =>
              pokemonEvolutions.hasOwnProperty(p.species.speciesId) &&
              (!p.pauseEvolutions ||
                p.species.speciesId === SpeciesId.SLOWPOKE ||
                p.species.speciesId === SpeciesId.EEVEE ||
                p.species.speciesId === SpeciesId.KIRLIA ||
                p.species.speciesId === SpeciesId.SNORUNT),
          )
          .flatMap(p => {
            const evolutions = pokemonEvolutions[p.species.speciesId];
            return evolutions.filter(e => e.isValidItemEvolution(p));
          }),
        party
          .filter(
            p =>
              p.isFusion() &&
              p.fusionSpecies &&
              pokemonEvolutions.hasOwnProperty(p.fusionSpecies.speciesId) &&
              (!p.pauseEvolutions ||
                p.fusionSpecies.speciesId === SpeciesId.SLOWPOKE ||
                p.fusionSpecies.speciesId === SpeciesId.EEVEE ||
                p.fusionSpecies.speciesId === SpeciesId.KIRLIA ||
                p.fusionSpecies.speciesId === SpeciesId.SNORUNT),
          )
          .flatMap(p => {
            const evolutions = pokemonEvolutions[p.fusionSpecies!.speciesId];
            return evolutions.filter(e => e.isValidItemEvolution(p, true));
          }),
      ]
        .flat()
        .flatMap(e => e.evoItem)
        .filter(i => !!i && i > 50 === rare);

      if (!evolutionItemPool.length) {
        return null;
      }

      // TODO: should this use `randSeedItem`?
      return new EvolutionItemReward(evolutionItemPool[randSeedInt(evolutionItemPool.length)]!); // TODO: is the bang correct?
    });
    this.id = id;
  }
}

export class FormChangeItemRewardGenerator extends RewardGenerator {
  constructor(isRareFormChangeItem: boolean, id: RewardId) {
    super((party: Pokemon[], pregenArgs?: any[]) => {
      if (pregenArgs && pregenArgs.length === 1 && pregenArgs[0] in FormChangeItem) {
        return new FormChangeItemReward(pregenArgs[0] as FormChangeItem);
      }

      const formChangeItemPool = [
        ...new Set(
          party
            .filter(p => pokemonFormChanges.hasOwnProperty(p.species.speciesId))
            .flatMap(p => {
              const formChanges = pokemonFormChanges[p.species.speciesId];
              let formChangeItemTriggers = formChanges
                .filter(
                  fc =>
                    ((fc.formKey.indexOf(SpeciesFormKey.MEGA) === -1 &&
                      fc.formKey.indexOf(SpeciesFormKey.PRIMAL) === -1) ||
                      globalScene.trainerItems.hasItem(TrainerItemId.MEGA_BRACELET)) &&
                    ((fc.formKey.indexOf(SpeciesFormKey.GIGANTAMAX) === -1 &&
                      fc.formKey.indexOf(SpeciesFormKey.ETERNAMAX) === -1) ||
                      globalScene.trainerItems.hasItem(TrainerItemId.DYNAMAX_BAND)) &&
                    (!fc.conditions.length ||
                      fc.conditions.filter(cond => cond instanceof SpeciesFormChangeCondition && cond.predicate(p))
                        .length) &&
                    fc.preFormKey === p.getFormKey(),
                )
                .map(fc => fc.findTrigger(SpeciesFormChangeItemTrigger) as SpeciesFormChangeItemTrigger)
                .filter(t => t?.active && !p.heldItemManager.hasFormChangeItem(t.item));

              if (p.species.speciesId === SpeciesId.NECROZMA) {
                // technically we could use a simplified version and check for formChanges.length > 3, but in case any code changes later, this might break...
                let foundULTRA_Z = false,
                  foundN_LUNA = false,
                  foundN_SOLAR = false;
                formChangeItemTriggers.forEach((fc, _i) => {
                  console.log("Checking ", fc.item);
                  switch (fc.item) {
                    case FormChangeItem.ULTRANECROZIUM_Z:
                      foundULTRA_Z = true;
                      break;
                    case FormChangeItem.N_LUNARIZER:
                      foundN_LUNA = true;
                      break;
                    case FormChangeItem.N_SOLARIZER:
                      foundN_SOLAR = true;
                      break;
                  }
                });
                if (foundULTRA_Z && foundN_LUNA && foundN_SOLAR) {
                  // all three items are present -> user hasn't acquired any of the N_*ARIZERs -> block ULTRANECROZIUM_Z acquisition.
                  formChangeItemTriggers = formChangeItemTriggers.filter(
                    fc => fc.item !== FormChangeItem.ULTRANECROZIUM_Z,
                  );
                } else {
                  console.log("DID NOT FIND ");
                }
              }
              return formChangeItemTriggers;
            }),
        ),
      ]
        .flat()
        .flatMap(fc => fc.item)
        .filter(i => (i && i < 100) === isRareFormChangeItem);
      // convert it into a set to remove duplicate values, which can appear when the same species with a potential form change is in the party.

      if (!formChangeItemPool.length) {
        return null;
      }

      // TODO: should this use `randSeedItem`?
      return new FormChangeItemReward(formChangeItemPool[randSeedInt(formChangeItemPool.length)]);
    });
    this.id = id;
  }
}

export class WeightedReward {
  public reward: Reward;
  public weight: number | WeightedRewardWeightFunc;
  public maxWeight: number | WeightedRewardWeightFunc;

  constructor(
    rewardFunc: RewardFunc,
    weight: number | WeightedRewardWeightFunc,
    maxWeight?: number | WeightedRewardWeightFunc,
  ) {
    this.reward = rewardFunc();
    this.weight = weight;
    this.maxWeight = maxWeight || (!(weight instanceof Function) ? weight : 0);
  }
}

type BaseRewardOverride = {
  name: Exclude<RewardKeys, GeneratorRewardOverride["name"]>;
  count?: number;
};

/** Type for modifiers and held items that are constructed via {@linkcode RewardGenerator}. */
export type GeneratorRewardOverride = {
  count?: number;
} & (
  | {
      name: keyof Pick<typeof rewardInitObj, "SPECIES_STAT_BOOSTER" | "RARE_SPECIES_STAT_BOOSTER">;
      type?: SpeciesStatBoosterItemId;
    }
  | {
      name: keyof Pick<typeof rewardInitObj, "TEMP_STAT_STAGE_BOOSTER">;
      type?: TempBattleStat;
    }
  | {
      name: keyof Pick<typeof rewardInitObj, "BASE_STAT_BOOSTER">;
      type?: Stat;
    }
  | {
      name: keyof Pick<typeof rewardInitObj, "MINT">;
      type?: Nature;
    }
  | {
      name: keyof Pick<typeof rewardInitObj, "ATTACK_TYPE_BOOSTER" | "TERA_SHARD">;
      type?: PokemonType;
    }
  | {
      name: keyof Pick<typeof rewardInitObj, "BERRY">;
      type?: BerryType;
    }
  | {
      name: keyof Pick<typeof rewardInitObj, "EVOLUTION_ITEM" | "RARE_EVOLUTION_ITEM">;
      type?: EvolutionItem;
    }
  | {
      name: keyof Pick<typeof rewardInitObj, "FORM_CHANGE_ITEM" | "RARE_FORM_CHANGE_ITEM">;
      type?: FormChangeItem;
    }
  | {
      name: keyof Pick<typeof rewardInitObj, "TM_COMMON" | "TM_GREAT" | "TM_ULTRA">;
      type?: MoveId;
    }
);

/** Type used to construct modifiers and held items for overriding purposes. */
export type RewardOverride = GeneratorRewardOverride | BaseRewardOverride;

const rewardInitObj = Object.freeze({
  // Pokeball rewards
  POKEBALL: () => new AddPokeballReward("pb", PokeballType.POKEBALL, 5, RewardId.POKEBALL),
  GREAT_BALL: () => new AddPokeballReward("gb", PokeballType.GREAT_BALL, 5, RewardId.GREAT_BALL),
  ULTRA_BALL: () => new AddPokeballReward("ub", PokeballType.ULTRA_BALL, 5, RewardId.ULTRA_BALL),
  ROGUE_BALL: () => new AddPokeballReward("rb", PokeballType.ROGUE_BALL, 5, RewardId.ROGUE_BALL),
  MASTER_BALL: () => new AddPokeballReward("mb", PokeballType.MASTER_BALL, 1, RewardId.MASTER_BALL),

  // Voucher rewards
  VOUCHER: () => new AddVoucherReward(VoucherType.REGULAR, 1, RewardId.VOUCHER),
  VOUCHER_PLUS: () => new AddVoucherReward(VoucherType.PLUS, 1, RewardId.VOUCHER_PLUS),
  VOUCHER_PREMIUM: () => new AddVoucherReward(VoucherType.PREMIUM, 1, RewardId.VOUCHER_PREMIUM),

  // Money rewards
  NUGGET: () =>
    new AddMoneyReward(
      "modifierType:ModifierType.NUGGET",
      "nugget",
      1,
      "modifierType:ModifierType.MoneyRewardModifierType.extra.small",
      RewardId.NUGGET,
    ),
  BIG_NUGGET: () =>
    new AddMoneyReward(
      "modifierType:ModifierType.BIG_NUGGET",
      "big_nugget",
      2.5,
      "modifierType:ModifierType.MoneyRewardModifierType.extra.moderate",
      RewardId.BIG_NUGGET,
    ),
  RELIC_GOLD: () =>
    new AddMoneyReward(
      "modifierType:ModifierType.RELIC_GOLD",
      "relic_gold",
      10,
      "modifierType:ModifierType.MoneyRewardModifierType.extra.large",
      RewardId.RELIC_GOLD,
    ),

  // Party-wide consumables
  RARER_CANDY: () => new AllPokemonLevelIncrementReward("modifierType:ModifierType.RARER_CANDY", "rarer_candy"),
  SACRED_ASH: () => new AllPokemonFullReviveReward("modifierType:ModifierType.SACRED_ASH", "sacred_ash"),

  // Pokemon consumables
  RARE_CANDY: () => new PokemonLevelIncrementReward("modifierType:ModifierType.RARE_CANDY", "rare_candy"),

  EVOLUTION_ITEM: () => new EvolutionItemRewardGenerator(false, RewardId.EVOLUTION_ITEM),
  RARE_EVOLUTION_ITEM: () => new EvolutionItemRewardGenerator(true, RewardId.RARE_EVOLUTION_ITEM),

  POTION: () => new PokemonHpRestoreReward("modifierType:ModifierType.POTION", "potion", RewardId.POTION, 20, 10),
  SUPER_POTION: () =>
    new PokemonHpRestoreReward("modifierType:ModifierType.SUPER_POTION", "super_potion", RewardId.SUPER_POTION, 50, 25),
  HYPER_POTION: () =>
    new PokemonHpRestoreReward(
      "modifierType:ModifierType.HYPER_POTION",
      "hyper_potion",
      RewardId.HYPER_POTION,
      200,
      50,
    ),
  MAX_POTION: () =>
    new PokemonHpRestoreReward("modifierType:ModifierType.MAX_POTION", "max_potion", RewardId.MAX_POTION, 0, 100),
  FULL_RESTORE: () =>
    new PokemonHpRestoreReward(
      "modifierType:ModifierType.FULL_RESTORE",
      "full_restore",
      RewardId.FULL_RESTORE,
      0,
      100,
      true,
    ),

  REVIVE: () => new PokemonReviveReward("modifierType:ModifierType.REVIVE", "revive", RewardId.REVIVE, 50),
  MAX_REVIVE: () =>
    new PokemonReviveReward("modifierType:ModifierType.MAX_REVIVE", "max_revive", RewardId.MAX_REVIVE, 100),

  FULL_HEAL: () => new PokemonStatusHealReward("modifierType:ModifierType.FULL_HEAL", "full_heal"),

  ETHER: () => new PokemonPpRestoreReward("modifierType:ModifierType.ETHER", "ether", RewardId.ETHER, 10),
  MAX_ETHER: () =>
    new PokemonPpRestoreReward("modifierType:ModifierType.MAX_ETHER", "max_ether", RewardId.MAX_ETHER, -1),

  ELIXIR: () => new PokemonAllMovePpRestoreReward("modifierType:ModifierType.ELIXIR", "elixir", RewardId.ELIXIR, 10),
  MAX_ELIXIR: () =>
    new PokemonAllMovePpRestoreReward("modifierType:ModifierType.MAX_ELIXIR", "max_elixir", RewardId.MAX_ELIXIR, -1),

  PP_UP: () => new PokemonPpUpReward("modifierType:ModifierType.PP_UP", "pp_up", RewardId.PP_UP, 1),
  PP_MAX: () => new PokemonPpUpReward("modifierType:ModifierType.PP_MAX", "pp_max", RewardId.PP_MAX, 3),

  /*REPEL: () => new DoubleBattleChanceBoosterReward('Repel', 5),
  SUPER_REPEL: () => new DoubleBattleChanceBoosterReward('Super Repel', 10),
  MAX_REPEL: () => new DoubleBattleChanceBoosterReward('Max Repel', 25),*/

  MINT: () => new MintRewardGenerator(),

  TERA_SHARD: () => new TeraTypeRewardGenerator(),

  TM_COMMON: () => new TmRewardGenerator(RarityTier.COMMON),
  TM_GREAT: () => new TmRewardGenerator(RarityTier.GREAT),
  TM_ULTRA: () => new TmRewardGenerator(RarityTier.ULTRA),

  MEMORY_MUSHROOM: () => new RememberMoveReward("modifierType:ModifierType.MEMORY_MUSHROOM", "big_mushroom"),

  DNA_SPLICERS: () => new FusePokemonReward("modifierType:ModifierType.DNA_SPLICERS", "dna_splicers"),

  // Form change items
  FORM_CHANGE_ITEM: () => new FormChangeItemRewardGenerator(false, RewardId.FORM_CHANGE_ITEM),
  RARE_FORM_CHANGE_ITEM: () => new FormChangeItemRewardGenerator(true, RewardId.RARE_FORM_CHANGE_ITEM),

  // Held items
  REVIVER_SEED: () => new HeldItemReward(HeldItemId.REVIVER_SEED),

  WHITE_HERB: () => new HeldItemReward(HeldItemId.WHITE_HERB),

  SPECIES_STAT_BOOSTER: () => new SpeciesStatBoosterRewardGenerator(false),
  RARE_SPECIES_STAT_BOOSTER: () => new SpeciesStatBoosterRewardGenerator(true),

  BASE_STAT_BOOSTER: () => new BaseStatBoosterRewardGenerator(),

  ATTACK_TYPE_BOOSTER: () => new AttackTypeBoosterRewardGenerator(),

  MYSTICAL_ROCK: () => new HeldItemReward(HeldItemId.MYSTICAL_ROCK),

  BERRY: () => new BerryRewardGenerator(),

  LUCKY_EGG: () => new HeldItemReward(HeldItemId.LUCKY_EGG),
  GOLDEN_EGG: () => new HeldItemReward(HeldItemId.GOLDEN_EGG),

  SOOTHE_BELL: () => new HeldItemReward(HeldItemId.SOOTHE_BELL),

  SCOPE_LENS: () => new HeldItemReward(HeldItemId.SCOPE_LENS),
  LEEK: () => new HeldItemReward(HeldItemId.LEEK),

  EVIOLITE: () => new HeldItemReward(HeldItemId.EVIOLITE),

  SOUL_DEW: () => new HeldItemReward(HeldItemId.SOUL_DEW),

  GOLDEN_PUNCH: () => new HeldItemReward(HeldItemId.GOLDEN_PUNCH),

  GRIP_CLAW: () => new HeldItemReward(HeldItemId.GRIP_CLAW),
  WIDE_LENS: () => new HeldItemReward(HeldItemId.WIDE_LENS),

  MULTI_LENS: () => new HeldItemReward(HeldItemId.MULTI_LENS),

  FOCUS_BAND: () => new HeldItemReward(HeldItemId.FOCUS_BAND),

  QUICK_CLAW: () => new HeldItemReward(HeldItemId.QUICK_CLAW),

  KINGS_ROCK: () => new HeldItemReward(HeldItemId.KINGS_ROCK),

  LEFTOVERS: () => new HeldItemReward(HeldItemId.LEFTOVERS),

  SHELL_BELL: () => new HeldItemReward(HeldItemId.SHELL_BELL),

  TOXIC_ORB: () => new HeldItemReward(HeldItemId.TOXIC_ORB),

  FLAME_ORB: () => new HeldItemReward(HeldItemId.FLAME_ORB),

  BATON: () => new HeldItemReward(HeldItemId.BATON),

  MINI_BLACK_HOLE: () => new HeldItemReward(HeldItemId.MINI_BLACK_HOLE),

  // Trainer items
  MEGA_BRACELET: () => new TrainerItemReward(TrainerItemId.MEGA_BRACELET),
  DYNAMAX_BAND: () => new TrainerItemReward(TrainerItemId.DYNAMAX_BAND),
  TERA_ORB: () => new TrainerItemReward(TrainerItemId.TERA_ORB),

  MAP: () => new TrainerItemReward(TrainerItemId.MAP),

  LURE: () => new LapsingTrainerItemReward(TrainerItemId.LURE, RewardId.LURE),
  SUPER_LURE: () => new LapsingTrainerItemReward(TrainerItemId.SUPER_LURE, RewardId.SUPER_LURE),
  MAX_LURE: () => new LapsingTrainerItemReward(TrainerItemId.MAX_LURE, RewardId.MAX_LURE),

  TEMP_STAT_STAGE_BOOSTER: () => new TempStatStageBoosterRewardGenerator(),

  DIRE_HIT: () => new LapsingTrainerItemReward(TrainerItemId.DIRE_HIT, RewardId.TEMP_STAT_STAGE_BOOSTER),

  EXP_SHARE: () => new TrainerItemReward(TrainerItemId.EXP_SHARE),
  EXP_BALANCE: () => new TrainerItemReward(TrainerItemId.EXP_BALANCE),

  OVAL_CHARM: () => new TrainerItemReward(TrainerItemId.OVAL_CHARM),

  EXP_CHARM: () => new TrainerItemReward(TrainerItemId.EXP_CHARM),
  SUPER_EXP_CHARM: () => new TrainerItemReward(TrainerItemId.SUPER_EXP_CHARM),

  AMULET_COIN: () => new TrainerItemReward(TrainerItemId.AMULET_COIN),

  LOCK_CAPSULE: () => new TrainerItemReward(TrainerItemId.LOCK_CAPSULE),

  HEALING_CHARM: () => new TrainerItemReward(TrainerItemId.HEALING_CHARM),
  CANDY_JAR: () => new TrainerItemReward(TrainerItemId.CANDY_JAR),

  BERRY_POUCH: () => new TrainerItemReward(TrainerItemId.BERRY_POUCH),

  SHINY_CHARM: () => new TrainerItemReward(TrainerItemId.SHINY_CHARM),
  ABILITY_CHARM: () => new TrainerItemReward(TrainerItemId.ABILITY_CHARM),
  CATCHING_CHARM: () => new TrainerItemReward(TrainerItemId.CATCHING_CHARM),

  IV_SCANNER: () => new TrainerItemReward(TrainerItemId.IV_SCANNER),

  GOLDEN_POKEBALL: () => new TrainerItemReward(TrainerItemId.GOLDEN_POKEBALL),

  // Tokens //TODO: do we even need them here?
  ENEMY_DAMAGE_BOOSTER: () => new TrainerItemReward(TrainerItemId.ENEMY_DAMAGE_BOOSTER),
  ENEMY_DAMAGE_REDUCTION: () => new TrainerItemReward(TrainerItemId.ENEMY_DAMAGE_REDUCTION),
  //ENEMY_SUPER_EFFECT_BOOSTER: () => new Reward('Type Advantage Token', 'Increases damage of super effective attacks by 30%', (type, _args) => new EnemySuperEffectiveDamageBoosterModifier(type, 30), 'wl_custom_super_effective'),
  ENEMY_HEAL: () => new TrainerItemReward(TrainerItemId.ENEMY_HEAL),
  ENEMY_ATTACK_POISON_CHANCE: () => new TrainerItemReward(TrainerItemId.ENEMY_ATTACK_POISON_CHANCE),
  ENEMY_ATTACK_PARALYZE_CHANCE: () => new TrainerItemReward(TrainerItemId.ENEMY_ATTACK_PARALYZE_CHANCE),
  ENEMY_ATTACK_BURN_CHANCE: () => new TrainerItemReward(TrainerItemId.ENEMY_ATTACK_BURN_CHANCE),
  ENEMY_STATUS_EFFECT_HEAL_CHANCE: () => new TrainerItemReward(TrainerItemId.ENEMY_STATUS_EFFECT_HEAL_CHANCE),
  ENEMY_ENDURE_CHANCE: () => new TrainerItemReward(TrainerItemId.ENEMY_ENDURE_CHANCE),
  ENEMY_FUSED_CHANCE: () => new TrainerItemReward(TrainerItemId.ENEMY_FUSED_CHANCE),

  // Items from mystery encounters
  MYSTERY_ENCOUNTER_SHUCKLE_JUICE_GOOD: () => new HeldItemReward(HeldItemId.SHUCKLE_JUICE_GOOD),
  MYSTERY_ENCOUNTER_SHUCKLE_JUICE_BAD: () => new HeldItemReward(HeldItemId.SHUCKLE_JUICE_BAD),

  MYSTERY_ENCOUNTER_OLD_GATEAU: () => new HeldItemReward(HeldItemId.OLD_GATEAU),

  MYSTERY_ENCOUNTER_BLACK_SLUDGE: () => new TrainerItemReward(TrainerItemId.BLACK_SLUDGE),

  MYSTERY_ENCOUNTER_MACHO_BRACE: () => new HeldItemReward(HeldItemId.MACHO_BRACE),

  MYSTERY_ENCOUNTER_GOLDEN_BUG_NET: () => new TrainerItemReward(TrainerItemId.GOLDEN_BUG_NET),
});

/**
 * The initial set of modifier types, used to generate the modifier pool.
 */
export type Rewards = typeof rewardInitObj;
export type RewardKeys = keyof typeof rewardInitObj;

export interface RewardPool {
  [tier: string]: WeightedReward[];
}

const rewardPoolWeights = {};

/**
 * Allows a unit test to check if an item exists in the Consumable Pool. Checks the pool directly, rather than attempting to reroll for the item.
 */
export const itemPoolChecks: Map<RewardKeys, boolean | undefined> = new Map();

export function generateRewardPoolWeights(party: Pokemon[], poolType: RewardPoolType, rerollCount = 0) {
  const pool = getRewardPoolForType(poolType);
  itemPoolChecks.forEach((_v, k) => {
    itemPoolChecks.set(k, false);
  });

  for (const tier of Object.keys(pool)) {
    const poolWeights = pool[tier].map(w => {
      if (w.reward instanceof TrainerItemReward) {
        const id = w.reward.itemId;
        if (globalScene.trainerItems.isMaxStack(id)) {
          return 0;
        }
      }
      if (typeof w.weight === "number") {
        return w.weight;
      }
      return w.weight(party, rerollCount);
    });
    rewardPoolWeights[tier] = poolWeights;
  }
}
export interface CustomRewardSettings {
  guaranteedRarityTiers?: RarityTier[];
  guaranteedRewardOptions?: RewardOption[];
  /** If specified, will override the next X items to be auto-generated from specific modifier functions (these don't have to be pre-genned). */
  guaranteedRewardFuncs?: RewardFunc[];
  /**
   * If set to `true`, will fill the remainder of shop items that were not overridden by the 3 options above, up to the `count` param value.
   * @example
   * ```ts
   * count = 4;
   * customRewardSettings = { guaranteedRarityTiers: [RarityTier.GREAT], fillRemaining: true };
   * ```
   * The first item in the shop will be `GREAT` tier, and the remaining `3` items will be generated normally.
   *
   * If `fillRemaining: false` in the same scenario, only 1 `GREAT` tier item will appear in the shop (regardless of the value of `count`).
   * @defaultValue `false`
   */
  fillRemaining?: boolean;
  /** If specified, can adjust the amount of money required for a shop reroll. If set to a negative value, the shop will not allow rerolls at all. */
  rerollMultiplier?: number;
  /**
   * If `false`, will prevent set item tiers from upgrading via luck.
   * @defaultValue `true`
   */
  allowLuckUpgrades?: boolean;
}

export function getRewardFuncById(id: string): RewardFunc {
  return rewardInitObj[id];
}

/**
 * Generates modifier options for a {@linkcode SelectRewardPhase}
 * @param count - Determines the number of items to generate
 * @param party - Party is required for generating proper modifier pools
 * @param rarityTiers - (Optional) If specified, rolls items in the specified tiers. Commonly used for tier-locking with Lock Capsule.
 * @param customRewardSettings - See {@linkcode CustomRewardSettings}
 */
export function getPlayerRewardOptions(
  count: number,
  party: PlayerPokemon[],
  rarityTiers?: RarityTier[],
  customRewardSettings?: CustomRewardSettings,
): RewardOption[] {
  const options: RewardOption[] = [];
  const retryCount = Math.min(count * 5, 50);
  if (!customRewardSettings) {
    for (let i = 0; i < count; i++) {
      const tier = rarityTiers && rarityTiers.length > i ? rarityTiers[i] : undefined;
      options.push(getRewardOptionWithRetry(options, retryCount, party, tier));
    }
  } else {
    // Guaranteed mod options first
    if (customRewardSettings?.guaranteedRewardOptions && customRewardSettings.guaranteedRewardOptions.length > 0) {
      options.push(...customRewardSettings.guaranteedRewardOptions!);
    }

    // Guaranteed mod functions second
    if (customRewardSettings.guaranteedRewardFuncs && customRewardSettings.guaranteedRewardFuncs.length > 0) {
      customRewardSettings.guaranteedRewardFuncs!.forEach((mod, _i) => {
        const rewardId = Object.keys(rewardInitObj).find(k => rewardInitObj[k] === mod) as string;
        const guaranteedMod: Reward = rewardInitObj[rewardId]?.();

        // Populates item id and tier
        const guaranteedModTier = getRewardDefaultTier(guaranteedMod);

        const modType = guaranteedMod instanceof RewardGenerator ? guaranteedMod.generateReward(party) : guaranteedMod;
        if (modType) {
          const option = new RewardOption(modType, 0, guaranteedModTier);
          options.push(option);
        }
      });
    }

    // Guaranteed tiers third
    if (customRewardSettings.guaranteedRarityTiers && customRewardSettings.guaranteedRarityTiers.length > 0) {
      const allowLuckUpgrades = customRewardSettings.allowLuckUpgrades ?? true;
      for (const tier of customRewardSettings.guaranteedRarityTiers) {
        options.push(getRewardOptionWithRetry(options, retryCount, party, tier, allowLuckUpgrades));
      }
    }

    // Fill remaining
    if (options.length < count && customRewardSettings.fillRemaining) {
      while (options.length < count) {
        options.push(getRewardOptionWithRetry(options, retryCount, party, undefined));
      }
    }
  }

  overridePlayerRewardOptions(options, party);

  return options;
}

/**
 * Will generate a {@linkcode Reward} from the {@linkcode RewardPoolType.PLAYER} pool, attempting to retry duplicated items up to retryCount
 * @param existingOptions Currently generated options
 * @param retryCount How many times to retry before allowing a dupe item
 * @param party Current player party, used to calculate items in the pool
 * @param tier If specified will generate item of tier
 * @param allowLuckUpgrades `true` to allow items to upgrade tiers (the little animation that plays and is affected by luck)
 */
function getRewardOptionWithRetry(
  existingOptions: RewardOption[],
  retryCount: number,
  party: PlayerPokemon[],
  tier?: RarityTier,
  allowLuckUpgrades?: boolean,
): RewardOption {
  allowLuckUpgrades = allowLuckUpgrades ?? true;
  let candidate = getNewRewardOption(party, RewardPoolType.PLAYER, tier, undefined, 0, allowLuckUpgrades);
  let r = 0;
  while (
    existingOptions.length &&
    ++r < retryCount &&
    //TODO: Improve this condition to refine what counts as a dupe
    existingOptions.filter(o => o.type.name === candidate?.type.name || o.type.group === candidate?.type.group).length
  ) {
    console.log("Retry count:", r);
    console.log(candidate?.type.group);
    console.log(candidate?.type.name);
    console.log(existingOptions.filter(o => o.type.name === candidate?.type.name).length);
    console.log(existingOptions.filter(o => o.type.group === candidate?.type.group).length);
    candidate = getNewRewardOption(
      party,
      RewardPoolType.PLAYER,
      candidate?.type.tier ?? tier,
      candidate?.upgradeCount,
      0,
      allowLuckUpgrades,
    );
  }
  return candidate!;
}

/**
 * Replaces the {@linkcode Reward} of the entries within {@linkcode options} with any
 * {@linkcode RewardOverride} entries listed in {@linkcode Overrides.ITEM_REWARD_OVERRIDE}
 * up to the smallest amount of entries between {@linkcode options} and the override array.
 * @param options Array of naturally rolled {@linkcode RewardOption}s
 * @param party Array of the player's current party
 */
export function overridePlayerRewardOptions(options: RewardOption[], party: PlayerPokemon[]) {
  const minLength = Math.min(options.length, Overrides.ITEM_REWARD_OVERRIDE.length);
  for (let i = 0; i < minLength; i++) {
    const override: RewardOverride = Overrides.ITEM_REWARD_OVERRIDE[i];
    const rewardFunc = rewardInitObj[override.name];
    let reward: Reward | RewardGenerator | null = rewardFunc();

    if (reward instanceof RewardGenerator) {
      const pregenArgs = "type" in override && override.type !== null ? [override.type] : undefined;
      reward = reward.generateReward(party, pregenArgs);
    }

    if (reward) {
      options[i].type = reward;
      options[i].tier = getRewardDefaultTier(reward);
    }
  }
}

export function getPlayerShopRewardOptionsForWave(waveIndex: number, baseCost: number): RewardOption[] {
  if (!(waveIndex % 10)) {
    return [];
  }

  const options = [
    [
      new RewardOption(allRewards.POTION(), 0, baseCost * 0.2),
      new RewardOption(allRewards.ETHER(), 0, baseCost * 0.4),
      new RewardOption(allRewards.REVIVE(), 0, baseCost * 2),
    ],
    [
      new RewardOption(allRewards.SUPER_POTION(), 0, baseCost * 0.45),
      new RewardOption(allRewards.FULL_HEAL(), 0, baseCost),
    ],
    [new RewardOption(allRewards.ELIXIR(), 0, baseCost), new RewardOption(rewardInitObj.MAX_ETHER(), 0, baseCost)],
    [
      new RewardOption(allRewards.HYPER_POTION(), 0, baseCost * 0.8),
      new RewardOption(allRewards.MAX_REVIVE(), 0, baseCost * 2.75),
      new RewardOption(allRewards.MEMORY_MUSHROOM(), 0, baseCost * 4),
    ],
    [
      new RewardOption(allRewards.MAX_POTION(), 0, baseCost * 1.5),
      new RewardOption(allRewards.MAX_ELIXIR(), 0, baseCost * 2.5),
    ],
    [new RewardOption(allRewards.FULL_RESTORE(), 0, baseCost * 2.25)],
    [new RewardOption(allRewards.SACRED_ASH(), 0, baseCost * 10)],
  ];
  return options.slice(0, Math.ceil(Math.max(waveIndex + 10, 0) / 30)).flat();
}

/**
 * Generates a Reward from the specified pool
 * @param party party of the trainer using the item
 * @param poolType PLAYER/WILD/TRAINER
 * @param baseTier If specified, will override the initial tier of an item (can still upgrade with luck)
 * @param upgradeCount If defined, means that this is a new Reward being generated to override another via luck upgrade. Used for recursive logic
 * @param retryCount Max allowed tries before the next tier down is checked for a valid Reward
 * @param allowLuckUpgrades Default true. If false, will not allow Reward to randomly upgrade to next tier
 */
function getNewRewardOption(
  party: Pokemon[],
  poolType: RewardPoolType,
  baseTier?: RarityTier,
  upgradeCount?: number,
  retryCount = 0,
  allowLuckUpgrades = true,
): RewardOption | null {
  const player = !poolType;
  const pool = getRewardPoolForType(poolType);
  const weights = getPoolWeights(poolType);

  let tier = 0;
  if (isNullOrUndefined(baseTier)) {
    baseTier = randomBaseTier();
  }
  if (isNullOrUndefined(upgradeCount)) {
    upgradeCount = allowLuckUpgrades ? getUpgradeCount(party, player, baseTier) : 0;
    tier = baseTier + upgradeCount;
  } else {
    tier = baseTier;
  }

  const tierWeights = weights[tier];
  const index = pickWeightedIndex(tierWeights);

  if (index === undefined) {
    return null;
  }

  let reward: Reward | null = pool[tier][index].reward;
  if (reward instanceof RewardGenerator) {
    reward = (reward as RewardGenerator).generateReward(party);
    if (reward === null) {
      if (player) {
        console.log(RarityTier[tier], upgradeCount);
      }
      return getNewRewardOption(party, poolType, tier, upgradeCount, ++retryCount);
    }
  }

  console.log(reward, !player ? "(enemy)" : "");

  return new RewardOption(reward as Reward, upgradeCount!, tier); // TODO: is this bang correct?
}

function getPoolWeights(poolType: RewardPoolType) {
  let weights: object;
  switch (poolType) {
    case RewardPoolType.PLAYER:
      weights = rewardPoolWeights;
      break;
  }
  return weights;
}

function randomBaseTier(): RarityTier {
  const tierValue = randSeedInt(1024);

  if (tierValue > 255) {
    return RarityTier.COMMON;
  }
  if (tierValue > 60) {
    return RarityTier.GREAT;
  }
  if (tierValue > 12) {
    return RarityTier.ULTRA;
  }
  if (tierValue) {
    return RarityTier.ROGUE;
  }
  return RarityTier.MASTER;
}

function getUpgradeCount(
  party: Pokemon[],
  player: boolean,
  baseTier: RarityTier,
  allowLuckUpgrades = true,
): RarityTier {
  const pool = getRewardPoolForType(RewardPoolType.PLAYER);
  let upgradeCount = 0;
  if (player) {
    if (baseTier < RarityTier.MASTER && allowLuckUpgrades) {
      const partyLuckValue = getPartyLuckValue(party);
      const upgradeOdds = Math.floor(128 / ((partyLuckValue + 4) / 4));
      while (pool.hasOwnProperty(baseTier + upgradeCount + 1) && pool[baseTier + upgradeCount + 1].length) {
        if (randSeedInt(upgradeOdds) < 4) {
          upgradeCount++;
        } else {
          break;
        }
      }
    }
  }
  return upgradeCount;
}

export function getDefaultRewardForTier(tier: RarityTier): Reward {
  const rewardPool = getRewardPoolForType(RewardPoolType.PLAYER);
  const weightedReward: WeightedReward = rewardPool[tier || RarityTier.COMMON][0];
  return weightedReward.reward;
}

export class RewardOption {
  public type: Reward;
  public upgradeCount: number;
  public tier: RarityTier;
  public cost: number;

  constructor(type: Reward, upgradeCount: number, tier: RarityTier, cost = 0) {
    this.type = type;
    this.upgradeCount = upgradeCount;
    this.tier = tier;
    this.cost = Math.min(Math.round(cost), Number.MAX_SAFE_INTEGER);
  }
}

/**
 * Calculates the team's luck value.
 * @param party The player's party.
 * @returns A number between 0 and 14 based on the party's total luck value, or a random number between 0 and 14 if the player is in Daily Run mode.
 */
export function getPartyLuckValue(party: Pokemon[]): number {
  if (globalScene.gameMode.isDaily) {
    const DailyLuck = new NumberHolder(0);
    globalScene.executeWithSeedOffset(
      () => {
        DailyLuck.value = randSeedInt(15); // Random number between 0 and 14
      },
      0,
      globalScene.seed,
    );
    return DailyLuck.value;
  }
  const eventSpecies = timedEventManager.getEventLuckBoostedSpecies();
  const luck = Phaser.Math.Clamp(
    party
      .map(p => (p.isAllowedInBattle() ? p.getLuck() + (eventSpecies.includes(p.species.speciesId) ? 1 : 0) : 0))
      .reduce((total: number, value: number) => (total += value), 0),
    0,
    14,
  );
  return Math.min(timedEventManager.getEventLuckBoost() + (luck ?? 0), 14);
}

export function getLuckString(luckValue: number): string {
  return ["D", "C", "C+", "B-", "B", "B+", "A-", "A", "A+", "A++", "S", "S+", "SS", "SS+", "SSS"][luckValue];
}

export function getLuckTextTint(luckValue: number): number {
  let rarityTier: RarityTier;
  if (luckValue > 11) {
    rarityTier = RarityTier.LUXURY;
  } else if (luckValue > 9) {
    rarityTier = RarityTier.MASTER;
  } else if (luckValue > 5) {
    rarityTier = RarityTier.ROGUE;
  } else if (luckValue > 2) {
    rarityTier = RarityTier.ULTRA;
  } else if (luckValue) {
    rarityTier = RarityTier.GREAT;
  } else {
    rarityTier = RarityTier.COMMON;
  }
  return getRarityTierTextTint(rarityTier);
}

export function initRewards() {
  for (const [key, value] of Object.entries(rewardInitObj)) {
    allRewards[key] = value;
  }
}

// TODO: If necessary, add the rest of the modifier types here.
// For now, doing the minimal work until the modifier rework lands.
const RewardConstructorMap = Object.freeze({
  RewardGenerator,
});

/**
 * Map of of modifier type strings to their constructor type
 */
export type RewardConstructorMap = typeof RewardConstructorMap;

/**
 * Map of modifier type strings to their instance type
 */
export type RewardInstanceMap = {
  [K in keyof RewardConstructorMap]: InstanceType<RewardConstructorMap[K]>;
};

export type RewardString = keyof RewardConstructorMap;
